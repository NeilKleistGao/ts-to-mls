//│ class A 
//│   x: number
//│ class B 
//│ tupleIt: string -> (mut in unit out string,)
//│ swap: ({x: number}, {},) -> (B, A,)
//│ class FFF 
//│   fff: T -> unit
//│ fff: FFF[string] -> string -> unit
//│ foo: (T & U) -> unit
//│ vec2: number -> number -> (number, number,)
//│ s: bool -> (string | number, number | false | true,)
//│ ex: T -> U -> (T, U, T & U,)
//│ third: (number, number, number,) -> number
//│ getFFF: unit -> FFF[number]
//│ twoFunctions: (mut number, mut number,) -> number -> number
//│ conv: {y: number} -> ({y: number}, {z: string},)
//│ value: (string, bool,) -> bool
//│ key: (string, bool,) -> string
//│ s2: (bool, string | number,) -> (string | number)
